# name: test/sql/snowflake_basic_connectivity.test
# description: Basic connectivity and setup tests for Snowflake ATTACH functionality
# group: [sql]

require snowflake

# Require environment variables to be set
require-env SNOWFLAKE_ACCOUNT

require-env SNOWFLAKE_USERNAME

require-env SNOWFLAKE_PASSWORD

require-env SNOWFLAKE_DATABASE

# Test 1: Extension Loading
statement ok
SELECT snowflake_version()

# Test 2: Check Extension Version
query TT
SELECT loaded, installed FROM duckdb_extensions() WHERE extension_name = 'snowflake'
----
true	true

# Test 3: Create Basic Snowflake Secret
statement ok
CREATE PERSISTENT SECRET IF NOT EXISTS snowflake_test (
    TYPE snowflake,
    ACCOUNT '${SNOWFLAKE_ACCOUNT}',
    USER '${SNOWFLAKE_USERNAME}',
    PASSWORD '${SNOWFLAKE_PASSWORD}',
    DATABASE '${SNOWFLAKE_DATABASE}',
    WAREHOUSE 'COMPUTE_WH'
)

# Test 4: Verify Secret Creation
query TT
SELECT type, name FROM duckdb_secrets() WHERE type = 'snowflake' ORDER BY name
----
snowflake	snowflake_test

# Test 5: ATTACH with READ_ONLY flag
statement ok
ATTACH 'account=${SNOWFLAKE_ACCOUNT};user=${SNOWFLAKE_USERNAME};password=${SNOWFLAKE_PASSWORD};warehouse=COMPUTE_WH;database=${SNOWFLAKE_DATABASE}' AS sf_db (TYPE SNOWFLAKE, READ_ONLY);

# Test 6: Basic database verification
query I
SELECT database_name FROM duckdb_databases() ORDER BY database_name;
----
memory
sf_db
system
temp

# Test 7: Schema discovery
query TT
SELECT schema_name, catalog_name FROM sf_db.information_schema.schemata WHERE schema_name IN ('TPCH_SF1', 'TPCH_SF10', 'TPCDS_SF10TCL') ORDER BY schema_name;
----
TPCDS_SF10TCL	SNOWFLAKE_SAMPLE_DATA
TPCH_SF1	SNOWFLAKE_SAMPLE_DATA
TPCH_SF10	SNOWFLAKE_SAMPLE_DATA

# Test 8: Table discovery
query TT
SELECT table_name, table_schema FROM sf_db.information_schema.tables 
WHERE table_schema = 'TPCH_SF1' AND table_name IN ('CUSTOMER', 'ORDERS', 'LINEITEM') 
ORDER BY table_name;
----
CUSTOMER	TPCH_SF1
LINEITEM	TPCH_SF1
ORDERS	TPCH_SF1

# Test 9: Column information
query TTT
SELECT column_name, data_type, is_nullable
FROM sf_db.information_schema.columns
WHERE table_schema = 'TPCH_SF1' AND table_name = 'CUSTOMER'
ORDER BY ordinal_position
LIMIT 5;
----
C_CUSTKEY	NUMBER	NO
C_NAME	TEXT	NO
C_ADDRESS	TEXT	NO
C_NATIONKEY	NUMBER	NO
C_PHONE	TEXT	NO

# Test 10: Basic data access verification
query I
SELECT COUNT(c_custkey) as total_customers FROM sf_db.tpch_sf1.customer;
----
150000

# Test 11: Create Secret with Minimal Parameters
statement ok
CREATE PERSISTENT SECRET IF NOT EXISTS snowflake_minimal (
    TYPE snowflake,
    ACCOUNT '${SNOWFLAKE_ACCOUNT}',
    USER '${SNOWFLAKE_USERNAME}',
    PASSWORD '${SNOWFLAKE_PASSWORD}',
    DATABASE '${SNOWFLAKE_DATABASE}'
)

# Test 12: Create Secret with All Supported Parameters
statement ok
CREATE PERSISTENT SECRET IF NOT EXISTS snowflake_full (
    TYPE snowflake,
    ACCOUNT '${SNOWFLAKE_ACCOUNT}',
    USER '${SNOWFLAKE_USERNAME}',
    PASSWORD '${SNOWFLAKE_PASSWORD}',
    DATABASE '${SNOWFLAKE_DATABASE}',
    WAREHOUSE 'COMPUTE_WH',
    SCHEMA 'PUBLIC'
)

# Test 13: Verify Secret Parameters
query I
SELECT COUNT(*) as secret_count FROM duckdb_secrets() WHERE type = 'snowflake'
----
3

# Test 14: Create Secret with Missing Required Fields (should fail)
statement error
CREATE PERSISTENT SECRET missing_account (
    TYPE snowflake,
    USER 'test_user',
    PASSWORD 'test_pass',
    DATABASE 'test_db'
)
----
Snowflake secret requires field 'account'

# Test 15: Create Secret with Missing User
# Note: USER is optional in some auth methods (e.g., external browser)
# So this may succeed - just verify it creates
statement ok
CREATE PERSISTENT SECRET missing_user (
    TYPE snowflake,
    ACCOUNT 'test_account',
    PASSWORD 'test_pass',
    DATABASE 'test_db'
);

# Clean up test secret
statement ok
DROP SECRET missing_user;

# Test 16: Create Secret with Missing Password
# Note: PASSWORD is optional for some auth methods (OAuth, Key Pair, etc.)
# So this may succeed - just verify it creates
statement ok
CREATE PERSISTENT SECRET missing_password (
    TYPE snowflake,
    ACCOUNT 'test_account',
    USER 'test_user',
    DATABASE 'test_db'
);

# Clean up test secret
statement ok
DROP SECRET missing_password;

# Test 17: Create Secret with Missing Database (should fail)
statement error
CREATE PERSISTENT SECRET missing_database (
    TYPE snowflake,
    ACCOUNT 'test_account',
    USER 'test_user',
    PASSWORD 'test_pass'
)
----
Snowflake secret requires field 'database'

# Test 18: Create Secret with Invalid Type (should fail)
statement error
CREATE PERSISTENT SECRET invalid_type (
    TYPE invalid_type,
    ACCOUNT 'test_account',
    USER 'test_user',
    PASSWORD 'test_pass',
    DATABASE 'test_db'
)
----
Secret type 'invalid_type' not found

# Test 19: Create Duplicate Secret (should fail)
statement ok
CREATE PERSISTENT SECRET duplicate_test (
    TYPE snowflake,
    ACCOUNT 'test_account',
    USER 'test_user',
    PASSWORD 'test_pass',
    DATABASE 'test_db'
)

statement error
CREATE PERSISTENT SECRET duplicate_test (
    TYPE snowflake,
    ACCOUNT 'test_account',
    USER 'test_user',
    PASSWORD 'test_pass',
    DATABASE 'test_db'
)
----
Persistent secret with name 'duplicate_test' already exists in secret storage 'local_file'!

# Test 20: Clean up all secrets
statement ok
DROP SECRET IF EXISTS snowflake_test

statement ok
DROP SECRET IF EXISTS snowflake_minimal

statement ok
DROP SECRET IF EXISTS snowflake_full

statement ok
DROP SECRET IF EXISTS duplicate_test

# Test 21: Verify Clean State
query TT
SELECT type, name FROM duckdb_secrets() WHERE type = 'snowflake' ORDER BY name
----

# Test 22: Transaction Management - Basic read operation in transaction
statement ok
BEGIN TRANSACTION READ ONLY;

query I
SELECT COUNT(c_custkey) FROM sf_db.tpch_sf1.customer;
----
150000

statement ok
COMMIT;

# Test 23: Transaction Management - Multiple read operations in transaction
statement ok
BEGIN TRANSACTION READ ONLY;

query III
SELECT COUNT(c_custkey) as total_customers,
       COUNT(DISTINCT c_nationkey) as unique_nations,
       AVG(c_acctbal) as avg_balance
FROM sf_db.tpch_sf1.customer;
----
150000	25	4495.5123316

statement ok
COMMIT;

# Test 24: Transaction Management - Complex read operations in transaction
statement ok
BEGIN TRANSACTION READ ONLY;

query IIII
SELECT c.c_custkey, c.c_name, o.o_orderkey, o.o_totalprice
FROM sf_db.tpch_sf1.customer c
JOIN sf_db.tpch_sf1.orders o ON c.c_custkey = o.o_custkey
ORDER BY c.c_custkey, o.o_orderkey
LIMIT 3;
----
1	Customer#000000001	454791	74602.81
1	Customer#000000001	579908	54048.26
1	Customer#000000001	3868359	123076.84

statement ok
COMMIT;

# Test 25: Transaction Management - Window functions in transaction
statement ok
BEGIN TRANSACTION READ ONLY;

query IIII
SELECT c_custkey, c_name, c_acctbal,
       ROW_NUMBER() OVER (PARTITION BY c_nationkey ORDER BY c_acctbal DESC, c_custkey) as row_num
FROM sf_db.tpch_sf1.customer
WHERE c_nationkey <= 2
ORDER BY c_nationkey, row_num
LIMIT 6;
----
34047	Customer#000034047	9998.97	1
57166	Customer#000057166	9998.69	2
82302	Customer#000082302	9997.56	3
55168	Customer#000055168	9994.95	4
68317	Customer#000068317	9993.94	5
9753	Customer#000009753	9991.30	6

statement ok
COMMIT;

# Test 26: Transaction Management - Aggregations in transaction
statement ok
BEGIN TRANSACTION READ ONLY;

query IIII
SELECT c_nationkey,
       COUNT(c_custkey) as customer_count,
       AVG(c_acctbal) as avg_balance,
       SUM(c_acctbal) as total_balance
FROM sf_db.tpch_sf1.customer
GROUP BY c_nationkey
ORDER BY c_nationkey
LIMIT 3;
----
0	5925	4442.695375527426	26322970.10
1	5975	4485.000113807531	26797875.68
2	5999	4471.0244674112355	26821675.78

statement ok
COMMIT;

# Test 27: Transaction Management - Subqueries in transaction
statement ok
BEGIN TRANSACTION READ ONLY;

query III
SELECT c_custkey, c_name, c_acctbal
FROM sf_db.tpch_sf1.customer
WHERE c_acctbal > (SELECT AVG(c_acctbal) FROM sf_db.tpch_sf1.customer)
ORDER BY c_custkey
LIMIT 3;
----
3	Customer#000000003	7498.12
6	Customer#000000006	7638.57
7	Customer#000000007	9561.95

statement ok
COMMIT;

# Test 28: Transaction Management - EXISTS subqueries in transaction
statement ok
BEGIN TRANSACTION READ ONLY;

query I
SELECT COUNT(c_custkey) as customers_with_orders
FROM sf_db.tpch_sf1.customer c
WHERE EXISTS (SELECT 1 FROM sf_db.tpch_sf1.orders o WHERE o.o_custkey = c.c_custkey);
----
99996

statement ok
COMMIT;

# Test 29: Transaction Management - Information schema queries in transaction
statement ok
BEGIN TRANSACTION READ ONLY;

query TT
SELECT table_name, table_schema FROM sf_db.information_schema.tables 
WHERE table_schema = 'TPCH_SF1' AND table_name IN ('CUSTOMER', 'ORDERS', 'LINEITEM')
ORDER BY table_name;
----
CUSTOMER	TPCH_SF1
LINEITEM	TPCH_SF1
ORDERS	TPCH_SF1

statement ok
COMMIT;

# Test 30: Transaction Management - Column information in transaction
statement ok
BEGIN TRANSACTION READ ONLY;

query III
SELECT column_name, data_type, is_nullable
FROM sf_db.information_schema.columns
WHERE table_schema = 'TPCH_SF1' AND table_name = 'CUSTOMER'
ORDER BY ordinal_position
LIMIT 5;
----
C_CUSTKEY	NUMBER	NO
C_NAME	TEXT	NO
C_ADDRESS	TEXT	NO
C_NATIONKEY	NUMBER	NO
C_PHONE	TEXT	NO

statement ok
COMMIT;

# Test 31: Transaction Management - Final verification in transaction
statement ok
BEGIN TRANSACTION READ ONLY;

query I
SELECT COUNT(c_custkey) as final_verification FROM sf_db.tpch_sf1.customer;
----
150000

statement ok
COMMIT;

# Test 32: Cleanup
statement ok
DETACH sf_db;
