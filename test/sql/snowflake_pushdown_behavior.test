# name: test/sql/snowflake_pushdown_behavior.test
# description: Test to verify pushdown behavior for snowflake_query vs ATTACH
# group: [sql]

# This test suite verifies that:
# 1. snowflake_query() does NOT have automatic filter/projection pushdown
# 2. ATTACH storage extension DOES have automatic filter/projection pushdown

require snowflake

# Note: enable_external_access is a startup setting and cannot be changed during runtime
# Tests should work with default settings (pushdown controlled via ATTACH options)

# Require environment variables for Snowflake connection
require-env SNOWFLAKE_ACCOUNT

require-env SNOWFLAKE_USERNAME

require-env SNOWFLAKE_PASSWORD

require-env SNOWFLAKE_DATABASE

# Test 1: Extension Loading
statement ok
SELECT snowflake_version()

# Test 2: Create Snowflake Secret
statement ok
CREATE PERSISTENT SECRET IF NOT EXISTS snowflake_pushdown_behavior_test (
    TYPE snowflake,
    ACCOUNT '${SNOWFLAKE_ACCOUNT}',
    USER '${SNOWFLAKE_USERNAME}',
    PASSWORD '${SNOWFLAKE_PASSWORD}',
    DATABASE '${SNOWFLAKE_DATABASE}',
    WAREHOUSE 'COMPUTE_WH'
);

# Test 3: Verify snowflake_query exists and does NOT advertise pushdown support
# snowflake_query should have projection_pushdown=false and filter_pushdown=false
query I
SELECT COUNT(*) FROM duckdb_functions() WHERE function_name = 'snowflake_query'
----
1

# Test 4: snowflake_query - Filter in SQL string (CORRECT usage)
# All filtering happens in the SQL string passed to Snowflake
# This is the correct way to use snowflake_query with filters
# Using simple numeric query to avoid Arrow conversion issues
query I
SELECT result FROM snowflake_query(
    'SELECT 1 as result',
    'snowflake_pushdown_behavior_test'
)
----
1

# Test 4a: snowflake_query with actual customer data
query I
SELECT COUNT(*) = 10 FROM snowflake_query(
    'SELECT C_CUSTKEY FROM ${SNOWFLAKE_DATABASE}.TPCH_SF1.CUSTOMER WHERE C_CUSTKEY <= 10',
    'snowflake_pushdown_behavior_test'
)
----
true

# Test 5: snowflake_query - Demonstrates that filters should be in SQL string
# All filtering happens server-side, not in outer WHERE clause
query I
SELECT COUNT(*) = 1 FROM snowflake_query(
    'SELECT C_CUSTKEY FROM ${SNOWFLAKE_DATABASE}.TPCH_SF1.CUSTOMER WHERE C_CUSTKEY = 1',
    'snowflake_pushdown_behavior_test'
)
----
true

# Test 5a: Multiple filters in SQL string
query I
SELECT COUNT(*) > 0 FROM snowflake_query(
    'SELECT C_CUSTKEY FROM ${SNOWFLAKE_DATABASE}.TPCH_SF1.CUSTOMER WHERE C_CUSTKEY <= 10 AND C_ACCTBAL > 0',
    'snowflake_pushdown_behavior_test'
)
----
true

# Test 6: ATTACH - Automatic filter pushdown
# Attach the Snowflake database
statement ok
ATTACH '' AS snow_test (
    TYPE snowflake,
    SECRET snowflake_pushdown_behavior_test,
    READ_ONLY
);

# Test 7: Verify ATTACH creates tables
query I
SELECT COUNT(*) > 0 FROM duckdb_tables() WHERE database_name = 'snow_test'
----
1

# Test 8: ATTACH - WHERE clause is automatically pushed down (WITH PUSHDOWN ENABLED)
# This is the recommended approach - DuckDB pushes the filter to Snowflake
# Only matching rows are transferred
query I
SELECT COUNT(*) FROM snow_test.tpch_sf1.customer WHERE C_CUSTKEY = 1
----
1

# Test 8a: EXPLAIN shows pushdown is happening
# The FILTER_PUSH clause should appear in the explain output
statement ok
EXPLAIN SELECT COUNT(*) FROM snow_test.tpch_sf1.customer WHERE C_CUSTKEY = 1;

# Test 8b: Compare pushdown vs non-pushdown results (should be identical)
# Store result with pushdown
statement ok
CREATE TABLE result_with_pushdown AS 
SELECT COUNT(*) as cnt FROM snow_test.tpch_sf1.customer WHERE C_CUSTKEY = 1;

# Detach and re-attach without enable_pushdown to disable pushdown
statement ok
DETACH snow_test;

statement ok
ATTACH '' AS snow_test (
    TYPE snowflake,
    SECRET snowflake_pushdown_behavior_test,
    READ_ONLY
);

# Query without pushdown
statement ok
CREATE TABLE result_without_pushdown AS 
SELECT COUNT(*) as cnt FROM snow_test.tpch_sf1.customer WHERE C_CUSTKEY = 1;

# Results should be identical regardless of pushdown
query I
SELECT (SELECT cnt FROM result_with_pushdown) = (SELECT cnt FROM result_without_pushdown);
----
true

# Clean up comparison tables
statement ok
DROP TABLE result_with_pushdown;

statement ok
DROP TABLE result_without_pushdown;

# Re-attach with pushdown for remaining tests
statement ok
DETACH snow_test;

statement ok
ATTACH '' AS snow_test (
    TYPE snowflake,
    SECRET snowflake_pushdown_behavior_test,
    READ_ONLY,
    enable_pushdown true
);

# Test 9: ATTACH - Projection pushdown
# Only requested columns are transferred from Snowflake
# Verify query returns data with proper columns
query I
SELECT COUNT(*) = 3 FROM (
    SELECT C_CUSTKEY, C_NAME
    FROM snow_test.tpch_sf1.customer
    WHERE C_NATIONKEY = 1
    LIMIT 3
);
----
true

# Verify columns are not null
query I
SELECT COUNT(*) = 3 FROM (
    SELECT C_CUSTKEY, C_NAME
    FROM snow_test.tpch_sf1.customer
    WHERE C_NATIONKEY = 1 AND C_CUSTKEY IS NOT NULL AND C_NAME IS NOT NULL
    LIMIT 3
);
----
true

# Test 10: ATTACH - Complex filters with AND/OR are pushed down
# Verify complex filter works and returns data
query I
SELECT COUNT(*) > 0
FROM snow_test.tpch_sf1.customer
WHERE C_NATIONKEY = 1 AND C_ACCTBAL > 5000
----
true

# Test 11: ATTACH - IN clause pushdown
# Verify IN clause works with pushdown
query I
SELECT COUNT(*) > 0
FROM snow_test.tpch_sf1.lineitem
WHERE L_ORDERKEY IN (1, 2, 3, 4, 5)
----
true

# Test 12: ATTACH - Range filter pushdown (BETWEEN operator)
# Verify BETWEEN works with pushdown
query I
SELECT COUNT(*) > 0
FROM snow_test.tpch_sf1.lineitem
WHERE L_ORDERKEY BETWEEN 1 AND 100
----
true

# Verify BETWEEN constraint is enforced
query I
SELECT COUNT(*) FROM (
    SELECT L_ORDERKEY
    FROM snow_test.tpch_sf1.lineitem
    WHERE L_ORDERKEY BETWEEN 1 AND 100
) WHERE L_ORDERKEY < 1 OR L_ORDERKEY > 100;
----
0

# Test 12a: EXPLAIN for BETWEEN pushdown
statement ok
EXPLAIN SELECT COUNT(*) FROM snow_test.tpch_sf1.lineitem WHERE L_ORDERKEY BETWEEN 1 AND 100;

# Test 13: Hybrid Query - snowflake_query with local table JOIN
# Create a local DuckDB table
statement ok
CREATE TABLE local_orders AS 
SELECT * FROM (VALUES 
    (1, 'Priority'),
    (2, 'Standard'),
    (3, 'Express')
) AS t(order_id, priority);

# Test 13a: Join snowflake_query results with local table
# Verify hybrid query works and returns data
query I
SELECT COUNT(*) > 0 FROM (
    SELECT 
        sf.L_ORDERKEY,
        sf.L_PARTKEY,
        lo.priority
    FROM snowflake_query(
        'SELECT L_ORDERKEY, L_PARTKEY FROM ${SNOWFLAKE_DATABASE}.TPCH_SF1.LINEITEM WHERE L_ORDERKEY <= 3',
        'snowflake_pushdown_behavior_test'
    ) sf
    JOIN local_orders lo ON sf.L_ORDERKEY = lo.order_id
    ORDER BY sf.L_ORDERKEY, sf.L_PARTKEY
    LIMIT 5
);
----
true

# Verify join constraint is respected (only order_ids 1,2,3)
query I
SELECT COUNT(*) FROM (
    SELECT sf.L_ORDERKEY
    FROM snowflake_query(
        'SELECT L_ORDERKEY FROM ${SNOWFLAKE_DATABASE}.TPCH_SF1.LINEITEM WHERE L_ORDERKEY <= 3',
        'snowflake_pushdown_behavior_test'
    ) sf
    JOIN local_orders lo ON sf.L_ORDERKEY = lo.order_id
) WHERE L_ORDERKEY > 3;
----
0

# Test 13b: EXPLAIN hybrid query to see execution plan
statement ok
EXPLAIN 
SELECT sf.L_ORDERKEY, lo.priority
FROM snowflake_query(
    'SELECT L_ORDERKEY FROM ${SNOWFLAKE_DATABASE}.TPCH_SF1.LINEITEM WHERE L_ORDERKEY <= 3',
    'snowflake_pushdown_behavior_test'
) sf
JOIN local_orders lo ON sf.L_ORDERKEY = lo.order_id;

# Test 14: Hybrid Query - ATTACH table with local aggregation
# Query Snowflake via ATTACH, then aggregate locally
# Verify aggregation with HAVING works
query I
SELECT COUNT(*) >= 3 FROM (
    SELECT 
        C_NATIONKEY,
        COUNT(*) as customer_count
    FROM snow_test.tpch_sf1.customer
    WHERE C_ACCTBAL > 5000
    GROUP BY C_NATIONKEY
    HAVING COUNT(*) > 2000
    ORDER BY customer_count DESC
    LIMIT 3
);
----
true

# Verify all results have count > 2000
query I
SELECT MIN(customer_count) > 2000 FROM (
    SELECT 
        C_NATIONKEY,
        COUNT(*) as customer_count
    FROM snow_test.tpch_sf1.customer
    WHERE C_ACCTBAL > 5000
    GROUP BY C_NATIONKEY
    HAVING COUNT(*) > 2000
    LIMIT 3
);
----
true

# Test 14a: EXPLAIN for hybrid aggregation
statement ok
EXPLAIN 
SELECT C_NATIONKEY, COUNT(*) as cnt
FROM snow_test.tpch_sf1.customer
WHERE C_ACCTBAL > 5000
GROUP BY C_NATIONKEY
HAVING COUNT(*) > 2000;

# Test 15: Hybrid Query - Union of snowflake_query and local data
query I
SELECT COUNT(*) FROM (
    SELECT C_CUSTKEY FROM snowflake_query(
        'SELECT C_CUSTKEY FROM ${SNOWFLAKE_DATABASE}.TPCH_SF1.CUSTOMER WHERE C_CUSTKEY <= 5',
        'snowflake_pushdown_behavior_test'
    )
    UNION ALL
    SELECT order_id FROM local_orders
)
----
8

# Test 16: Multiple BETWEEN conditions with ATTACH (pushdown test)
# Verify multiple BETWEEN works
query I
SELECT COUNT(*) > 0
FROM snow_test.tpch_sf1.lineitem
WHERE L_ORDERKEY BETWEEN 1 AND 50
  AND L_LINENUMBER BETWEEN 1 AND 3
----
true

# Verify BETWEEN constraints are enforced
query I
SELECT COUNT(*) FROM (
    SELECT L_ORDERKEY, L_LINENUMBER
    FROM snow_test.tpch_sf1.lineitem
    WHERE L_ORDERKEY BETWEEN 1 AND 50
      AND L_LINENUMBER BETWEEN 1 AND 3
) WHERE L_ORDERKEY < 1 OR L_ORDERKEY > 50 OR L_LINENUMBER < 1 OR L_LINENUMBER > 3;
----
0

# Test 16a: EXPLAIN for multiple BETWEEN filters
statement ok
EXPLAIN SELECT * FROM snow_test.tpch_sf1.lineitem 
WHERE L_ORDERKEY BETWEEN 1 AND 50 AND L_LINENUMBER BETWEEN 1 AND 3;

# Test 17: Profiling - Enable profiling to see query metrics
statement ok
PRAGMA enable_profiling;

statement ok
PRAGMA profiling_output='profile_output.json';

# Run a query with profiling enabled
query I
SELECT COUNT(*) > 0 FROM snow_test.tpch_sf1.customer WHERE C_NATIONKEY BETWEEN 1 AND 5
----
true

# Disable profiling
statement ok
PRAGMA disable_profiling;

# Test 18: Clean up local tables
statement ok
DROP TABLE local_orders;

# Test 19: Final cleanup - detach and drop secret
statement ok
DETACH snow_test;

statement ok
DROP SECRET snowflake_pushdown_behavior_test;


