# name: test/sql/snowflake_read_operations.test
# description: Comprehensive read operations tests for Snowflake ATTACH functionality
# group: [sql]

require snowflake

# Require environment variables to be set
require-env SNOWFLAKE_ACCOUNT

require-env SNOWFLAKE_USERNAME

require-env SNOWFLAKE_PASSWORD

require-env SNOWFLAKE_DATABASE

# Test 1: ATTACH with READ_ONLY flag and pushdown enabled
# Enable pushdown to support virtual columns and complex queries
statement ok
ATTACH 'account=${SNOWFLAKE_ACCOUNT};user=${SNOWFLAKE_USERNAME};password=${SNOWFLAKE_PASSWORD};warehouse=COMPUTE_WH;database=${SNOWFLAKE_DATABASE}' AS sf_db (TYPE SNOWFLAKE, READ_ONLY, enable_pushdown true);

# Test 2: Basic SELECT with LIMIT
# Verify specific columns can be selected
statement ok
SELECT c_custkey FROM sf_db.tpch_sf1.customer LIMIT 3;

# Verify multiple columns work
statement ok
SELECT c_custkey, c_name FROM sf_db.tpch_sf1.customer LIMIT 3;

# Verify aggregation works (avoiding COUNT(*) which triggers query builder bug)
query I
SELECT COUNT(c_custkey) FROM sf_db.tpch_sf1.customer;
----
150000

# Test 3: Basic aggregations
# Verify aggregations work (not checking exact values)
query I
SELECT COUNT(c_custkey) > 100000 FROM sf_db.tpch_sf1.customer;
----
true

query I
SELECT COUNT(DISTINCT c_nationkey) > 20 FROM sf_db.tpch_sf1.customer;
----
true

query I
SELECT AVG(c_acctbal) > 0 FROM sf_db.tpch_sf1.customer;
----
true

# Test 4: JOIN operations
# Verify JOIN works and returns data
query I
SELECT COUNT(*) = 3 FROM (
    SELECT c.c_custkey, c.c_name, o.o_orderkey, o.o_totalprice
    FROM sf_db.tpch_sf1.customer c
    JOIN sf_db.tpch_sf1.orders o ON c.c_custkey = o.o_custkey
    ORDER BY c.c_custkey, o.o_orderkey
    LIMIT 3
);
----
true

# Verify join constraint (customer keys match order keys)
query I
SELECT COUNT(*) FROM (
    SELECT c.c_custkey, o.o_custkey
    FROM sf_db.tpch_sf1.customer c
    JOIN sf_db.tpch_sf1.orders o ON c.c_custkey = o.o_custkey
    LIMIT 100
) WHERE c_custkey != o_custkey;
----
0

# Test 5: Complex aggregations with GROUP BY
# Verify GROUP BY works and returns multiple nations
query I
SELECT COUNT(*) >= 3 FROM (
    SELECT c_nationkey,
           COUNT(c_custkey) as customer_count,
           AVG(c_acctbal) as avg_balance,
           SUM(c_acctbal) as total_balance
    FROM sf_db.tpch_sf1.customer
    GROUP BY c_nationkey
    ORDER BY c_nationkey
    LIMIT 3
);
----
true

# Verify each nation has customers
query I
SELECT MIN(customer_count) > 1000 FROM (
    SELECT COUNT(c_custkey) as customer_count
    FROM sf_db.tpch_sf1.customer
    GROUP BY c_nationkey
    LIMIT 3
);
----
true

# Test 6: Window functions
# Verify window functions work correctly
query I
SELECT COUNT(*) = 6 FROM (
    SELECT c_custkey, c_name, c_acctbal,
           ROW_NUMBER() OVER (PARTITION BY c_nationkey ORDER BY c_acctbal DESC) as row_num,
           RANK() OVER (PARTITION BY c_nationkey ORDER BY c_acctbal DESC) as rank_num,
           DENSE_RANK() OVER (PARTITION BY c_nationkey ORDER BY c_acctbal DESC) as dense_rank_num
    FROM sf_db.tpch_sf1.customer
    WHERE c_nationkey <= 2
    ORDER BY c_nationkey, row_num
    LIMIT 6
);
----
true

# Verify row numbers are sequential 1-6
query I
SELECT COUNT(DISTINCT row_num) = 6 FROM (
    SELECT ROW_NUMBER() OVER (PARTITION BY c_nationkey ORDER BY c_acctbal DESC) as row_num
    FROM sf_db.tpch_sf1.customer
    WHERE c_nationkey <= 2
    LIMIT 6
);
----
true

# Test 7: Subqueries
# Verify subquery with AVG works
query I
SELECT COUNT(*) > 0 FROM (
    SELECT c_custkey, c_name, c_acctbal
    FROM sf_db.tpch_sf1.customer
    WHERE c_acctbal > (SELECT AVG(c_acctbal) FROM sf_db.tpch_sf1.customer)
    ORDER BY c_custkey
    LIMIT 3
);
----
true

# Verify all results are above average
query I
SELECT MIN(c_acctbal) > (SELECT AVG(c_acctbal) FROM sf_db.tpch_sf1.customer) FROM (
    SELECT c_acctbal
    FROM sf_db.tpch_sf1.customer
    WHERE c_acctbal > (SELECT AVG(c_acctbal) FROM sf_db.tpch_sf1.customer)
    LIMIT 10
);
----
true

# Test 8: EXISTS subqueries
# Verify EXISTS works
query I
SELECT COUNT(c_custkey) > 50000
FROM sf_db.tpch_sf1.customer c
WHERE EXISTS (SELECT 1 FROM sf_db.tpch_sf1.orders o WHERE o.o_custkey = c.c_custkey);
----
true

# Test 9: NOT EXISTS subqueries
# Verify NOT EXISTS works  
query I
SELECT COUNT(c_custkey) > 0
FROM sf_db.tpch_sf1.customer c
WHERE NOT EXISTS (SELECT 1 FROM sf_db.tpch_sf1.orders o WHERE o.o_custkey = c.c_custkey);
----
true

# Verify both EXISTS and NOT EXISTS return data (complementary sets)
query I
SELECT (
    (SELECT COUNT(*) FROM sf_db.tpch_sf1.customer c
     WHERE EXISTS (SELECT 1 FROM sf_db.tpch_sf1.orders o WHERE o.o_custkey = c.c_custkey)) > 0
    AND
    (SELECT COUNT(*) FROM sf_db.tpch_sf1.customer c
     WHERE NOT EXISTS (SELECT 1 FROM sf_db.tpch_sf1.orders o WHERE o.o_custkey = c.c_custkey)) > 0
);
----
true

# Test 10: IN subqueries
# Verify IN works
query I
SELECT COUNT(c_custkey) > 10000
FROM sf_db.tpch_sf1.customer
WHERE c_nationkey IN (0, 1, 2);
----
true

# Test 11: NOT IN subqueries
# Verify NOT IN works
query I
SELECT COUNT(c_custkey) > 100000
FROM sf_db.tpch_sf1.customer
WHERE c_nationkey NOT IN (0, 1, 2);
----
true

# Verify IN and NOT IN work as complementary filters
# Both should return data
query I
SELECT (
    SELECT COUNT(*) FROM sf_db.tpch_sf1.customer WHERE c_nationkey IN (0, 1, 2)
) > 0
AND (
    SELECT COUNT(*) FROM sf_db.tpch_sf1.customer WHERE c_nationkey NOT IN (0, 1, 2)
) > 0;
----
true

# Test 12: UNION operations
# Verify UNION works correctly
query I
SELECT COUNT(*) = 6 FROM (
    SELECT c_custkey, c_name FROM sf_db.tpch_sf1.customer WHERE c_custkey <= 3
    UNION
    SELECT c_custkey, c_name FROM sf_db.tpch_sf1.customer WHERE c_custkey >= 149997
    ORDER BY c_custkey
    LIMIT 6
);
----
true

# Verify UNION removes duplicates (compared to UNION ALL)
query I
SELECT (
    SELECT COUNT(*) FROM (
        SELECT c_custkey FROM sf_db.tpch_sf1.customer WHERE c_custkey <= 100
        UNION
        SELECT c_custkey FROM sf_db.tpch_sf1.customer WHERE c_custkey <= 100
    )
) = (
    SELECT COUNT(*) FROM (
        SELECT c_custkey FROM sf_db.tpch_sf1.customer WHERE c_custkey <= 100
    )
);
----
true

# Test 13: INTERSECT operations
# Verify INTERSECT works and returns overlapping values
query I
SELECT COUNT(*) > 0 FROM (
    SELECT c_custkey FROM sf_db.tpch_sf1.customer WHERE c_custkey <= 5
    INTERSECT
    SELECT c_custkey FROM sf_db.tpch_sf1.customer WHERE c_custkey >= 3
    ORDER BY c_custkey
);
----
true

# Verify INTERSECT only returns values in both sets
query I
SELECT MIN(c_custkey) >= 3 AND MAX(c_custkey) <= 5 FROM (
    SELECT c_custkey FROM sf_db.tpch_sf1.customer WHERE c_custkey <= 5
    INTERSECT
    SELECT c_custkey FROM sf_db.tpch_sf1.customer WHERE c_custkey >= 3
);
----
true

# Test 14: EXCEPT operations
# Verify EXCEPT works and returns non-overlapping values
query I
SELECT COUNT(*) > 0 FROM (
    SELECT c_custkey FROM sf_db.tpch_sf1.customer WHERE c_custkey <= 5
    EXCEPT
    SELECT c_custkey FROM sf_db.tpch_sf1.customer WHERE c_custkey >= 3
    ORDER BY c_custkey
);
----
true

# Verify EXCEPT only returns values in first set but not second
query I
SELECT MAX(c_custkey) < 3 FROM (
    SELECT c_custkey FROM sf_db.tpch_sf1.customer WHERE c_custkey <= 5
    EXCEPT
    SELECT c_custkey FROM sf_db.tpch_sf1.customer WHERE c_custkey >= 3
);
----
true

# Test 15: CASE expressions
# Verify CASE works and produces categories
query I
SELECT COUNT(DISTINCT balance_category) >= 3 FROM (
    SELECT 
           CASE 
               WHEN c_acctbal < 0 THEN 'Negative'
               WHEN c_acctbal = 0 THEN 'Zero'
               WHEN c_acctbal < 1000 THEN 'Low'
               WHEN c_acctbal < 5000 THEN 'Medium'
               ELSE 'High'
           END as balance_category
    FROM sf_db.tpch_sf1.customer
    LIMIT 1000
);
----
true

# Verify all categories are valid strings
query I
SELECT COUNT(*) FROM (
    SELECT CASE 
               WHEN c_acctbal < 0 THEN 'Negative'
               WHEN c_acctbal = 0 THEN 'Zero'
               WHEN c_acctbal < 1000 THEN 'Low'
               WHEN c_acctbal < 5000 THEN 'Medium'
               ELSE 'High'
           END as balance_category
    FROM sf_db.tpch_sf1.customer
    LIMIT 100
) WHERE balance_category NOT IN ('Negative', 'Zero', 'Low', 'Medium', 'High');
----
0

# Test 16: String operations
# Verify string functions work
query I
SELECT COUNT(*) = 3 FROM (
    SELECT c_name,
           UPPER(c_name) as upper_name,
           LOWER(c_name) as lower_name,
           LENGTH(c_name) as name_length,
           SUBSTRING(c_name, 1, 8) as name_prefix
    FROM sf_db.tpch_sf1.customer
    ORDER BY c_custkey
    LIMIT 3
);
----
true

# Verify UPPER converts to uppercase
query I
SELECT COUNT(*) FROM (
    SELECT c_name, UPPER(c_name) as upper_name
    FROM sf_db.tpch_sf1.customer
    LIMIT 100
) WHERE upper_name != UPPER(c_name);
----
0

# Verify LENGTH returns positive values
query I
SELECT MIN(LENGTH(c_name)) > 0 FROM sf_db.tpch_sf1.customer LIMIT 100;
----
true

# Test 17: Numeric operations
query IIIII
SELECT c_acctbal,
       ABS(c_acctbal) as abs_balance,
       ROUND(c_acctbal, 2) as rounded_balance,
       CEIL(c_acctbal) as ceiling_balance,
       FLOOR(c_acctbal) as floor_balance
FROM sf_db.tpch_sf1.customer
ORDER BY c_custkey
LIMIT 3;
----
711.56	711.56	711.56	712	711
121.65	121.65	121.65	122	121
7498.12	7498.12	7498.12	7499	7498

# Test 18: Multiple JOINs
query IIIII
SELECT c.c_custkey, c.c_name, o.o_orderkey, l.l_linenumber, l.l_quantity
FROM sf_db.tpch_sf1.customer c
JOIN sf_db.tpch_sf1.orders o ON c.c_custkey = o.o_custkey
JOIN sf_db.tpch_sf1.lineitem l ON o.o_orderkey = l.l_orderkey
ORDER BY c.c_custkey, o.o_orderkey, l.l_linenumber
LIMIT 6;
----
1	Customer#000000001	454791	1	40.00
1	Customer#000000001	454791	2	13.00
1	Customer#000000001	579908	1	33.00
1	Customer#000000001	3868359	1	36.00
1	Customer#000000001	3868359	2	9.00
1	Customer#000000001	3868359	3	32.00

# Test 19: Conditional aggregations
query IIII
SELECT c_nationkey,
       COUNT(c_custkey) as total_customers,
       COUNT(CASE WHEN c_acctbal > 5000 THEN 1 END) as high_balance_customers,
       COUNT(CASE WHEN c_acctbal < 1000 THEN 1 END) as low_balance_customers
FROM sf_db.tpch_sf1.customer
GROUP BY c_nationkey
ORDER BY c_nationkey
LIMIT 3;
----
0	5925	2628	1069
1	5975	2675	1066
2	5999	2665	1098

# Test 20: Common Table Expression (CTE)
query III
WITH customer_stats AS (
    SELECT 
        c_nationkey,
        COUNT(*) as customer_count,
        AVG(c_acctbal) as avg_balance
    FROM sf_db.tpch_sf1.customer 
    GROUP BY c_nationkey
)
SELECT 
    c_nationkey,
    customer_count,
    avg_balance
FROM customer_stats
ORDER BY customer_count DESC, c_nationkey
LIMIT 3;
----
9	6161	4533.433290050317
6	6100	4436.013193442623
19	6100	4544.851129508197

# Test 21: Final verification
query I
SELECT COUNT(c_custkey) as final_verification FROM sf_db.tpch_sf1.customer;
----
150000

# Test 22: Cleanup
statement ok
DETACH sf_db;
